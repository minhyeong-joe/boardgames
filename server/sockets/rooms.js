const { v4: uuidv4 } = require("uuid");

// userRooms is used to map user's socket id to the room id
// This makes room search from socket id efficient and fast
const userRooms = {};

// rooms are all game rooms not including the lobby that displays rooms for specific games
// rooms contain:
// id: uuid
// name: String room name
// memebers: [ { userId: ID generated by MongoDB, username: name of user, isOwner: Boolean, socketId: ID generated by socketIO } ]
// gameState: initially null, but receive corresponding gameState from client component (gameState has many forms based on game type)
// gameId: uuid
// password: String or null
// maxOccupancy: number of max occupancy
// isPrivate: automatically set to true if password is provided, else false
let rooms = [];

exports = module.exports = (io) => {
	io.on("connection", (socket) => {
		console.log(`socket connected: ${socket.id}`);

		// on user joinning the lobby (page that displays all the rooms for a game)
		socket.on("joinLobby", (payload, callback) => {
			const { gameId } = payload;
			socket.join(`lobby-${gameId}`);
			callback(getRooms(gameId));
		});

		// on user create a room via create_room_modal
		socket.on("createRoom", (payload, callback) => {
			const roomId = uuidv4();
			const roomnameExists = rooms.find((room) => room.name === payload.name);
			if (roomnameExists) {
				callback({ success: false, message: "Room name already in use" });
				return;
			}
			const newRoom = {
				...payload, // { name, password, maxOccupancy, gameId }
				gameState: null,
				isPrivate: payload.password ? true : false,
				id: roomId,
				members: [],
			};
			rooms.push(newRoom);
			callback({ success: true, roomId: newRoom.id });
		});

		socket.on("requestJoinRoom", (payload, callback) => {
			const { name, password } = payload;
			const roomToJoin = rooms.find((room) => room.name === name);
			// catch invalid join room requests
			if (!roomToJoin) {
				callback({ success: false, message: "Room does not exist" });
				return;
			}
			if (roomToJoin.members.length === roomToJoin.maxOccupancy) {
				callback({ success: false, message: "Room is already full" });
				return;
			}
			if (roomToJoin.isPrivate && password !== roomToJoin.password) {
				callback({ success: false, message: "Incorrect Password" });
				return;
			}
			callback({ success: true, roomId: roomToJoin.id });
		});

		// on user joining the game room
		// Note: after user creates a room, he/she will be redirected to the room and thus "joinRoom" and be added as the first member AKA owner.
		socket.on("joinRoom", (payload, callback) => {
			const { username, userId, roomId } = payload;
			const currentRoom = rooms.find((room) => room.id === roomId);
			// catch invalid accesses such as max occupied or password bypass through direct url typing, etc.
			// Only for direct url typing
			if (!currentRoom) {
				callback({ success: false, message: "Room does not exist" });
				return;
			}
			if (currentRoom.members.length === currentRoom.maxOccupancy) {
				callback({ success: false, message: "The room is full" });
				return;
			}
			if (currentRoom.gameState) {
				callback({ success: false, message: "A game is in progress" });
				return;
			}
			if (
				rooms.find((room) =>
					room.members.some((member) => member.userId === userId)
				)
			) {
				callback({ success: false, message: "Duplicate user session" });
				return;
			}
			// add new user (check if owner) to the room
			const firstPerson = currentRoom.members.length === 0;
			const newMember = {
				username,
				userId,
				socketId: socket.id,
				isOwner: firstPerson,
				isTurn: firstPerson,
			};
			currentRoom.members.push(newMember);
			// make a key pair of {socket id: room id}
			userRooms[socket.id] = roomId;
			// join the user to socket room
			socket.join(roomId);
			callback({ success: true, room: currentRoom });
			// update room info at the lobby
			socket.broadcast
				.to(`lobby-${currentRoom.gameId}`)
				.emit("loadRooms", { rooms: getRooms(currentRoom.gameId) });
			// update room info in the room
			socket.broadcast.to(roomId).emit("userJoinsRoom", { room: currentRoom });
			socket.emit("log", {
				timestamp: Date.now(),
				message: "Welcome to the room",
			});
			socket.broadcast.to(roomId).emit("log", {
				timestamp: Date.now(),
				message: `${newMember.username} has joined the room`,
			});
		});

		// on user send message
		socket.on("sendMessage", (payload) => {
			const { senderId, sendername, content } = payload;
			// find the room this user is in
			const roomId = userRooms[socket.id];
			io.in(roomId).emit("message", { senderId, sendername, content });
		});

		socket.on("disconnect", () => {
			console.log(`socket disconnected: ${socket.id}`);

			userExit(socket);
		});
	});
};

// returns all the rooms that are of specific game type (determined by gameId)
const getRooms = (gameId) => {
	return rooms
		.filter((room) => room.gameId === gameId) // find all rooms under specific gameId
		.map(({ password, id, ...rest }) => rest); // remove password from room objects
};

// user leaves a room (either manually or disconnecting through back navigation or browser exit)
const userExit = (socket) => {
	const roomId = userRooms[socket.id];
	if (roomId) {
		// user was at a game room and disconnected
		const room = rooms.find((room) => room.id === roomId);
		// if user is the first-turn next round, yield first-turn to next player
		const playerIndex = room.members.findIndex(
			(member) => member.socketId === socket.id
		);
		if (room.members[playerIndex].isTurn) {
			if (playerIndex + 1 >= room.members.length) {
				room.members[0].isTurn = true;
			} else {
				room.members[playerIndex + 1].isTurn = true;
			}
		}
		const username = room.members.find(
			(member) => member.socketId === socket.id
		).username;
		// remove user from the room
		room.members = room.members.filter(
			(member) => member.socketId !== socket.id
		);
		// remove {socket id: room id} pair
		delete userRooms[socket.id];
		socket.leave(roomId);
		// if everyone leaves, destroy room
		if (room.members.length === 0) {
			rooms = rooms.filter((room) => room.id !== roomId);
		} else {
			// guarantees the first member is always the owner
			room.members[0].isOwner = true;
		}
		socket.broadcast.to(`lobby-${room.gameId}`).emit("loadRooms", {
			rooms: getRooms(room.gameId),
		});
		socket.broadcast.to(roomId).emit("userExitsRoom", { room });
		socket.broadcast.to(roomId).emit("log", {
			timestamp: Date.now(),
			message: `${username} left the room`,
		});
	}
};
